// Generated by CoffeeScript 1.6.2
(function() {
  var Lexer, eval_args, eval_block, eval_call, eval_coffee, eval_expr, eval_literal, eval_property, eval_tree, eval_value, eval_value2, exports, last, lexer, nodes, parse, parser, unescape_string;

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    parser = require('coffee-script/lib/coffee-script/parser').parser;
    Lexer = require('coffee-script/lib/coffee-script/lexer').Lexer;
    nodes = require('coffee-script/lib/coffee-script/nodes');
    last = require('coffee-script/lib/coffee-script/helpers').last;
  } else {
    parser = CoffeeScript.require('./parser').parser;
    Lexer = CoffeeScript.require('./lexer').Lexer;
    nodes = CoffeeScript.require('./nodes');
    last = CoffeeScript.require('./helpers').last;
  }

  lexer = new Lexer;

  parse = function(code) {
    return parser.parse(lexer.tokenize(code));
  };

  unescape_string = function(s) {
    return s;
  };

  eval_property = function(base, property) {
    if (property instanceof nodes.Access) {
      if (!property.name.asKey) {
        throw new Error("Assert Error: property.name.asKey");
      }
      return base[property.name.value];
    } else {
      throw new Error("Not Implemented: " + property.constructor.name);
    }
  };

  eval_value2 = function(node, context) {
    var base, property, value, _i, _len, _ref;

    base = null;
    value = eval_tree(node.base, context);
    _ref = node.properties;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      property = _ref[_i];
      base = value;
      value = eval_property(value, property);
    }
    return [base, value];
  };

  eval_value = function(node, context) {
    return eval_value2(node, context)[1];
  };

  eval_args = function(args, context) {
    var a, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      a = args[_i];
      _results.push(eval_tree(a, context));
    }
    return _results;
  };

  eval_call = function(node, context) {
    var f, self, variable, _ref, _ref1;

    if (node.isNew) {
      throw Error("Not Implemented");
    }
    if (node.isSuper) {
      throw Error("Not Implemented");
    }
    variable = node.variable;
    if (!variable instanceof nodes.Value) {
      throw Error("Not Implemented");
    }
    if (variable.properties.length > 0 && last(variable.properties) instanceof nodes.Access) {
      _ref = eval_value2(variable, context), self = _ref[0], f = _ref[1];
    } else {
      _ref1 = eval_value2(variable, context), self = _ref1[0], f = _ref1[1];
    }
    return f.apply(self, eval_args(node.args, context));
  };

  eval_block = function(node, context) {
    var expr, result, _i, _len, _ref;

    _ref = node.expressions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      expr = _ref[_i];
      result = eval_tree(expr, context);
    }
    return result;
  };

  eval_literal = function(node, context) {
    var value;

    value = node.value;
    if (value.match(/^[$a-zA-Z][$\w]*$/)) {
      return context[value];
    } else if (value.match(/^\d+$/)) {
      return parseInt(value);
    } else if (value.match(/\d+\.\d+/)) {
      return parseFloat(value);
    } else if (value.match(/['"].*['"]/)) {
      return unescape_string(value.substring(1, value.length - 1));
    } else {
      throw Error("Not Implemented: " + value);
    }
  };

  eval_expr = function(node, context) {
    throw Error("Not Implemented: " + node);
  };

  eval_tree = function(node, globals) {
    if (node instanceof nodes.Block) {
      return eval_block(node, globals);
    } else if (node instanceof nodes.Call) {
      return eval_call(node, globals);
    } else if (node instanceof nodes.Value) {
      return eval_value(node, globals);
    } else if (node instanceof nodes.Literal) {
      return eval_literal(node, globals);
    } else {
      throw Error("Not Implemented: " + node);
    }
  };

  eval_coffee = function(code, globals) {
    if (globals == null) {
      globals = {};
    }
    return eval_tree(parse(code), globals);
  };

  exports = eval_coffee;

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = exports;
  } else {
    this.CoffeeScriptEval = exports;
  }

}).call(this);
