// Generated by CoffeeScript 1.6.2
(function() {
  var Lexer, eval_args, eval_array, eval_block, eval_call, eval_coffee, eval_dict, eval_expr, eval_literal, eval_op, eval_property, eval_tree, eval_value, eval_value2, exports, last, lexer, nodes, parse, parser, unescape_string;

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    parser = require('coffee-script/lib/coffee-script/parser').parser;
    Lexer = require('coffee-script/lib/coffee-script/lexer').Lexer;
    nodes = require('coffee-script/lib/coffee-script/nodes');
    last = require('coffee-script/lib/coffee-script/helpers').last;
  } else {
    parser = CoffeeScript.require('./parser').parser;
    Lexer = CoffeeScript.require('./lexer').Lexer;
    nodes = CoffeeScript.require('./nodes');
    last = CoffeeScript.require('./helpers').last;
  }

  lexer = new Lexer;

  parse = function(code) {
    return parser.parse(lexer.tokenize(code));
  };

  unescape_string = function(s) {
    return s;
  };

  eval_property = function(base, property) {
    if (property instanceof nodes.Access) {
      if (!property.name.asKey) {
        throw new Error("Assert Error: property.name.asKey");
      }
      return base[property.name.value];
    } else {
      throw new Error("Not Implemented: " + property.constructor.name);
    }
  };

  eval_value2 = function(node, context) {
    var base, property, value, _i, _len, _ref;

    base = null;
    value = eval_tree(node.base, context);
    _ref = node.properties;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      property = _ref[_i];
      base = value;
      value = eval_property(value, property);
    }
    return [base, value];
  };

  eval_value = function(node, context) {
    return eval_value2(node, context)[1];
  };

  eval_args = function(args, context) {
    var a, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      a = args[_i];
      _results.push(eval_tree(a, context));
    }
    return _results;
  };

  eval_call = function(node, context) {
    var f, self, variable, _ref, _ref1;

    if (node.isNew) {
      throw Error("Not Implemented");
    }
    if (node.isSuper) {
      throw Error("Not Implemented");
    }
    variable = node.variable;
    if (!variable instanceof nodes.Value) {
      throw Error("Not Implemented");
    }
    if (variable.properties.length > 0 && last(variable.properties) instanceof nodes.Access) {
      _ref = eval_value2(variable, context), self = _ref[0], f = _ref[1];
    } else {
      _ref1 = eval_value2(variable, context), self = _ref1[0], f = _ref1[1];
    }
    return f.apply(self, eval_args(node.args, context));
  };

  eval_block = function(node, context) {
    var expr, result, _i, _len, _ref;

    _ref = node.expressions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      expr = _ref[_i];
      result = eval_tree(expr, context);
    }
    return result;
  };

  eval_literal = function(node, context) {
    var m, value;

    value = node.value;
    if (value.match(/^[$a-zA-Z][$\w]*$/)) {
      return context[value];
    } else if (value.match(/^\d+$/)) {
      return parseInt(value);
    } else if (value.match(/^\d+\.\d+$/)) {
      return parseFloat(value);
    } else if (value.match(/^['"].*['"]$/)) {
      return unescape_string(value.substring(1, value.length - 1));
    } else if (value.match(/^\/(.*)\/(\w+)$/)) {
      m = value.match(/^\/(.*)\/(\w+)/);
      return new RegExp(m[1], m[2]);
    } else {
      throw Error("Not Implemented: " + value);
    }
  };

  eval_array = function(node, context) {
    var e, result, _i, _len, _ref;

    result = [];
    _ref = node.objects;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      result.push(eval_tree(e, context));
    }
    return result;
  };

  eval_dict = function(node, context) {
    var k, property, result, v, value, variable, _i, _len, _ref;

    if (!node.generated) {
      throw new Error("Assert Error: node.generated");
    }
    result = {};
    _ref = node.properties;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      property = _ref[_i];
      if (!property instanceof nodes.Assign) {
        throw new Error("Assert Error: property instanceof nodes.Assign");
      }
      variable = property.variable, value = property.value;
      k = variable.base.value;
      if (!k.match(/^\w+$/)) {
        if (k.match(/^['"].*['"]$/)) {
          k = unescape_string(k.substring(1, k.length - 1));
        } else {
          throw new Error("Not Implemented: " + k);
        }
      }
      v = eval_tree(value, context);
      result[k] = v;
    }
    return result;
  };

  eval_op = function(node, context) {
    if (node.operator === '+') {
      return eval_tree(node.first, context) + eval_tree(node.second, context);
    }
    if (node.operator === '-') {
      return eval_tree(node.first, context) - eval_tree(node.second, context);
    }
    if (node.operator === '*') {
      return eval_tree(node.first, context) * eval_tree(node.second, context);
    }
    if (node.operator === '/') {
      return eval_tree(node.first, context) / eval_tree(node.second, context);
    }
    if (node.operator === '%') {
      return eval_tree(node.first, context) % eval_tree(node.second, context);
    }
    throw new Error("Not Implemented: " + node.operator);
  };

  eval_expr = function(node, context) {
    throw Error("Not Implemented: " + node);
  };

  eval_tree = function(node, globals) {
    if (node instanceof nodes.Block) {
      return eval_block(node, globals);
    } else if (node instanceof nodes.Call) {
      return eval_call(node, globals);
    } else if (node instanceof nodes.Value) {
      return eval_value(node, globals);
    } else if (node instanceof nodes.Literal) {
      return eval_literal(node, globals);
    } else if (node instanceof nodes.Arr) {
      return eval_array(node, globals);
    } else if (node instanceof nodes.Obj) {
      return eval_dict(node, globals);
    } else if (node instanceof nodes.Op) {
      return eval_op(node, globals);
    } else {
      throw Error("Not Implemented: " + node);
    }
  };

  eval_coffee = function(code, globals) {
    if (globals == null) {
      globals = {};
    }
    return eval_tree(parse(code), globals);
  };

  exports = eval_coffee;

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = exports;
  } else {
    this.CoffeeScriptEval = exports;
  }

}).call(this);
